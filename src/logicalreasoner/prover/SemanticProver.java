package logicalreasoner.prover;

import logicalreasoner.inference.Branch;
import logicalreasoner.inference.Decomposition;
import logicalreasoner.inference.Inference;
import expression.sentence.Sentence;
import logicalreasoner.truthassignment.TruthAssignment;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * The SemanticProver class represents a logical reasoner
 * which determines the validity of arguments by
 * generating a TruthAssignment Tree (like a Truth Tree,
 * except that mappings from Sentences to their values are
 * stored in each node, not only the Sentences themselves).
 */
public class SemanticProver implements Runnable {

    private Set<Sentence> premises, interests;

    //Stores the initial/root TruthAssignment
    private TruthAssignment masterFunction;

    //The leaves of the TruthAssignment tree
    private List<TruthAssignment> openBranches;

    //All statements which can be branched upon (in descending order of size)
    private PriorityQueue<Branch> branchQueue;
    private int inferenceCount;

    //Keep an ordered list of inferences for proof printing
    private List<Inference> inferenceList;

    /**
     * Initialize the reasoner with the premises and the negation of all interests
     * @param premises the prior knowledge of the prover
     * @param interests the interests of the prover (to be negated)
     */
    public SemanticProver(Set<Sentence> premises, Set<Sentence> interests) {
        this.premises = premises;
        this.interests = interests;
        inferenceList = new ArrayList<>();
        inferenceCount = 1;
        masterFunction = new TruthAssignment();
        premises.forEach(s -> masterFunction.setTrue(s, 0));
        interests.forEach(s -> masterFunction.setFalse(s, 0));

        openBranches = new ArrayList<>();
        openBranches.add(masterFunction);

        branchQueue = new PriorityQueue<>((b1, b2) -> {
            if (b1.size() != b2.size())
                return b1.size() > b2.size() ? 1 : 0;
            return b1.getOrigin().size() > b2.getOrigin().size() ? 1 : 0;
        });
    }

    /**
     * Reason over the TruthAssignment h by decomposing statements
     * @param h the TruthAssignment to reason over
     * @return true if changes to h have been made as a result of this call, false otherwise
     */
    public boolean reason(TruthAssignment h) {
        List<Inference> inferences = h.getSentencesUpwards().stream()
                .filter(s -> !h.isDecomposed(s))
                .map(s -> s.reason(h, inferenceCount++)).filter(i -> i != null)
                .collect(Collectors.toList());

        inferences.forEach(i -> {
            h.setDecomposed(i.getOrigin());
            if (i instanceof Decomposition) {
                inferenceList.add(i);
                i.infer(h);
            } else if (i instanceof Branch)
                branchQueue.offer((Branch)i);
        });

        return !inferences.isEmpty();
    }

    /**
     * Run the prover over the given premises & conclusion
     */
    public void run() {
        System.out.println("Premises: " + premises);
        System.out.println("Interests: " + interests);

        while (!reasoningCompleted()) {
            boolean updated = true;

            // Always decompose all statements before branching
            while (!openBranches.isEmpty() && updated) {
                closeBranches();
                updated = openBranches.stream().map(this::reason).collect(Collectors.toList()).contains(true);
            }

            closeBranches();

            //Branch once on the largest branching statement then loop back around
            if (!openBranches.isEmpty() && !branchQueue.isEmpty())
                addBranches();
        }

        //If the tree has been completely decomposed
        //without inconsistencies, the argument is invalid
        if (isConsistent()) {
            System.out.println("\nThe argument is NOT valid.\n");
        } else {
            System.out.println("\nThe argument IS valid.\n");
        }

        printInferences();
        printInferenceList();
    }

    /**
     * Check if all TruthAssignments are consistent and fully decomposed.
     * @return true if all open branches are fully decomposed
     */
    private boolean reasoningCompleted() {
        return openBranches.isEmpty() || (branchQueue.isEmpty() && openBranches.stream().allMatch(TruthAssignment::decomposedAll));
    }

    public boolean isConsistent() {
        return !openBranches.isEmpty() && openBranches.stream().allMatch(TruthAssignment::isConsistent);
    }

    /**
     * Print the TruthAssignment tree generated by the argument
     */
    private void printInferences() {
        masterFunction.print();
        System.out.println();
    }

    /**
     * Print the Set of open Branches
     */
    public void printBranches() {
        System.out.println("Branches: ");
        openBranches.forEach(System.out::println);
        System.out.println("Branch Queue: " + branchQueue);
        System.out.println();
    }

    /**
     * Print the list of inferences made to build the truth tree
     */
    private void printInferenceList() {
        System.out.println("Inference List: ");
        inferenceList.forEach(System.out::println);
        System.out.println();
    }

    /**
     * Branch the Sentence on the top of the branchQueue
     * and update the openBranches Set to contain those children.
     */
    private void addBranches() {
        Branch b = branchQueue.poll();
        //System.out.println("Branching on: " + b);

        inferenceList.add(b);

        if (openBranches.isEmpty())  //Make sure no unnecessary branching occurs
            return;

        b.getParent().getLeaves().forEach(leaf -> {
            b.infer(leaf);
            leaf.getChildren().forEach(l -> openBranches.add(l));
            openBranches.remove(leaf);
        });

        closeBranches();    //Clean up any inconsistent branches
    }

    private void closeBranches() {
        openBranches.removeIf(b -> !b.isConsistent());
    }
}
