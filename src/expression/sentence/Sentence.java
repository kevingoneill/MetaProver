package expression.sentence;

import expression.Expression;
import expression.Sort;
import logicalreasoner.inference.Inference;
import logicalreasoner.truthassignment.TruthAssignment;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * The Sentence class represents any type of logical
 * Sentence, (ie. BooleanSentence, Proposition, Predicate, or generated by connectives)
 */
public abstract class Sentence extends Expression {
  protected ArrayList<Sentence> args;
  Sort sort;

  /**
   * Create a new logical Sentence
   *
   * @param a    its arguments
   * @param n    its name
   * @param s    its symbol
   * @param type its Sort
   */
  protected Sentence(ArrayList<Sentence> a, String n, String s, Sort type) {
    super(n, s);
    args = a;
    sort = type;
    HASH_CODE = toString().hashCode();
  }

  public abstract Sentence makeCopy();

  public abstract Boolean eval(TruthAssignment h);

  public abstract Inference reason(TruthAssignment h, int inferenceNum, int justificationNum);

  public String toString() {
    if (TOSTRING == null)
      TOSTRING = toSymbol();
    return TOSTRING;
    /*
    StringBuilder builder = new StringBuilder();
    builder.append("(").append(name);
    args.forEach(arg -> builder.append(" ").append(arg));
    builder.append(")");
    return builder.toString();
    */
  }

  public String toSymbol() {
    if (!args.isEmpty()) {
      StringBuilder builder = new StringBuilder();
      builder.append("(");
      for (int i = 0; i < args.size() - 1; ++i) {
        builder.append(args.get(i).toSymbol()).append(" ").append(symbol).append(" ");
      }
      builder.append(args.get(args.size() - 1).toSymbol()).append(")");
      return builder.toString();
    }
    return symbol;
  }

  public boolean equals(Object o) {
    return this.hashCode() == o.hashCode();
    /*
    if (this == o)
      return true;
    if (hashCode() != o.hashCode())
      return false;
    //return toString().equals(o.toString());
    if (o instanceof Sentence) {
      Sentence s = (Sentence) o;
      if (s.args.size() != args.size() || !s.name.equals(name))
        return false;

      for (int i = 0; i < args.size(); ++i) {
        if (!args.get(i).equals(s.args.get(i)))
          return false;
      }
      return true;
      //return IntStream.rangeClosed(0, args.size() - 1).allMatch(i -> args.get(i).equals(s.args.get(i)));

      //return toString().equals(o.toString());
    }
    return false;
    */
  }

  public boolean isAtomic() {
    return this instanceof Atom || this instanceof Predicate;
  }

  public boolean isLiteral() {
    return isAtomic() || this instanceof Not && args.get(0).isLiteral();
  }

  public int numArgs() {
    return args.size();
  }

  public int size() {
    return args.stream().mapToInt(Sentence::size).sum() + numArgs();
  }

  public Sort getSort() {
    return sort;
  }

  public boolean isQuantifier() {
    return false;
  }

  public Set<Sentence> getConstants() {
    return args.stream()
            .flatMap(s -> s.getConstants().stream())
            .collect(Collectors.toSet());
  }

  public abstract Sentence instantiate(Sentence c, Variable v);

  public int quantifierCount() {
    return args.stream().mapToInt(Sentence::quantifierCount)
            .reduce(isQuantifier() ? 1 : 0, (a, b) -> a + b);
  }

  public int atomCount() {
    return args.stream().mapToInt(Sentence::atomCount)
            .reduce(isAtomic() ? 1 : 0, (a, b) -> a + b);
  }

  public static Comparator<Sentence> quantifierComparator = (e1, e2) -> {
    if (e1 instanceof Exists) {   // Always instantiate existential quantifiers before universals
      if (e2 instanceof Exists)
        return e1.atomCount()
                - e2.atomCount();
      return -1;
    } else if (e2 instanceof Exists)
      return 1;
    ForAll f1 = (ForAll) e1,
            f2 = (ForAll) e2;

    if (f1.getSentence().isLiteral() && !f2.getSentence().isLiteral())
      return -1;
    else if (!f1.getSentence().isLiteral() && f2.getSentence().isLiteral())
      return 1;

    if (f1.getInstantiations().size() != f2.getInstantiations().size())
      return f1.getInstantiations().size() - f2.getInstantiations().size();


    int q1 = f1.quantifierCount(),
            q2 = f2.quantifierCount();   // Always instantiate statements with less quantifiers

    if (q1 != q2)
      return q1 - q2;

    if (f1.getSentence().size() != f2.getSentence().size())
      return f1.getSentence().size() - f2.getSentence().size();

    q1 = f1.atomCount();
    q2 = f2.atomCount();   // Always instantiate statements with less atoms
    if (q1 != q2)
      return q1 - q2;

    return f1.getSentence().numArgs() - f2.getSentence().numArgs();
  };
}
